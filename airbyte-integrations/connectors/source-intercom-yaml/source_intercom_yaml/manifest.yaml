version: "0.1.0"

definitions:

  ## Bases
  schema_loader:
    description: "Base JSON Schema loader"
    type: JsonSchema
    file_path: "./source_intercom_yaml/schemas/{{ options['name'] }}.json"
  selector:
    description: "Base records selector for Full Refresh streams"
    extractor:
      type: DpathExtractor
      field_pointer: ["{{ options.get('data_field', 'data')}}"] 
  requester:
    description: "Base Requester for Full Refresh streams"
    type: HttpRequester
    url_base: "https://api.intercom.io/"
    http_method: "GET"
    # TODO: ERRORS SHOULD BE HANDLED AS WELL!
    authenticator:
      type: BearerAuthenticator
      api_token: "{{ config['access_token'] }}"        
    request_options_provider:
      request_headers:
        # ATTENTION: API version change is possible here
        Intercom-Version: '2.5'
        Accept: 'application/json'
  retriever:
    description: "Base Retriever for Full Refresh streams"
    record_selector:
      $ref: "*ref(definitions.selector)"
    requester:
      $ref: "*ref(definitions.requester)"
    paginator:
      type: "DefaultPaginator"
      url_base: "*ref(definitions.requester.url_base)"
      pagination_strategy:
        type: "CursorPagination"
        cursor_value: "{{ response.get('pages', {}).get('next') }}"
        stop_condition: "{{ 'next' not in response.get('pages', {}) }}"
        page_size: 150
      page_size_option:
        inject_into: request_parameter
        field_name: per_page
      page_token_option:
        inject_into: path
  
  ## stream based overrides / base streams
  stream_full_refresh:
    retriever:
      $ref: "*ref(definitions.retriever)"
    schema_loader:
      $ref: "*ref(definitions.schema_loader)"
  stream_data_attributes:
    description: "https://developers.intercom.com/intercom-api-reference/reference#list-data-attributes"
    $ref: "*ref(definitions.stream_full_refresh)"
    retriever:
      $ref: "*ref(definitions.retriever)"
      requester:
        $ref: "*ref(definitions.requester)"
        request_options_provider:
          request_parameters:
            model: "{{ options.get('model') }}"
  stream_incremental_search:
    description: "https://developers.intercom.com/intercom-api-reference/reference/pagination-sorting-search"
    $ref: "*ref(definitions.stream_full_refresh)"
    $options:
      sort_order: "ascending"
    checkpoint_interval: 150
    retriever:
      $ref: "*ref(definitions.stream_full_refresh.retriever)"
      requester:
        $ref: "*ref(definitions.requester_incremental_search)"
      stream_slicer:
        $ref: "*ref(definitions.slicer_incremental_search)"
      record_selector:
        $ref: "*ref(definitions.selector)"
        record_filter:
          description: "
          Based on https://developers.intercom.com/intercom-api-reference/reference/pagination-sorting-search#pagination
          Section: `Warning about search context state`
          Action: we should apply additional filtering to avoid duplicated records
          "
          condition: "{{ record[options.get('stream_cursor_field')] >= stream_state.get(options.get('stream_cursor_field')) }}"
      paginator:
        type: "DefaultPaginator"
        url_base: "*ref(definitions.requester.url_base)"
        pagination_strategy:
          type: "CursorPagination"
          cursor_value: "{{ response.get('pages', {}).get('next') }}"
          stop_condition: "{{ 'next' not in response.get('pages', {}) }}"
  requester_incremental_search:
    description: "Requester for Incremental Search streams"
    $ref: "*ref(definitions.requester)"
    http_method: "POST"
    request_options_provider:
      $ref: "*ref(definitions.requester.request_options_provider)"
      request_body_json:
        query: "{
            'operator': 'OR',
            'value': [
                {
                    'field': '{{ options.get('stream_cursor_field') }}',
                    'operator': '>',
                    'value': {{ stream_state.get(options.get('stream_cursor_field'), format_datetime(config['start_date'], '%s')) }}
                },
                {
                    'field': '{{ options.get('stream_cursor_field') }}',
                    'operator': '=',
                    'value': {{ stream_state.get(options.get('stream_cursor_field'), format_datetime(config['start_date'], '%s')) }}
                },
            ],
        }"
        sort: "{
          'field': '{{ options.get('stream_cursor_field') }}', 
          'order': '{{ options.get('sort_order') }}'
        }"
        pagination: "{
          'per_page': {{ options.get('page_size') }},
          'page': {{ next_page_token.get('next_page_token').get('page') }},
          'starting_after': '{{ next_page_token.get('next_page_token').get('starting_after') }}'
        }"
  slicer_incremental_search:
    description: "Stands to produce 1 big slice, to track the cursor_field"
    type: "DatetimeStreamSlicer"
    cursor_field: "updated_at"
    start_datetime:
      datetime: "{{ format_datetime(config['start_date'], '%s') }}"
      datetime_format: '%s'
    end_datetime:
      datetime: "{{ now_local().strftime('%s') }}"
      datetime_format: '%s'
    step: "P100Y"
    datetime_format: '%s'
    cursor_granularity: "PT0.000001S"
  selector_conversation_parts:
    description: "Records selector for Conversation Parts stream"
    extractor:
      type: DpathExtractor
      field_pointer: ["conversation_parts", "conversation_parts"]
  
  ### STREAMS
  ## Full Rrefresh
  admins:
    description: "https://developers.intercom.com/intercom-api-reference/reference#list-admins"
    $ref: "*ref(definitions.stream_full_refresh)"
    $options:
      name: "admins"
      primary_key: "id"
      path: "admins"
      data_field: "admins"
  tags:
    description: "https://developers.intercom.com/intercom-api-reference/reference#list-tags-for-an-app"
    $ref: "*ref(definitions.stream_full_refresh)"
    $options:
      name: "tags"
      primary_key: "name"
      path: "tags"
  teams:
    description: "https://developers.intercom.com/intercom-api-reference/reference#list-teams"
    $ref: "*ref(definitions.stream_full_refresh)"
    $options:
      name: "teams"
      primary_key: "name"
      path: "teams"
      data_field: "teams"
  company_attributes:
    description: "https://developers.intercom.com/intercom-api-reference/reference#list-data-attributes"
    $ref: "*ref(definitions.stream_data_attributes)"
    $options:
      name: "company_attributes"
      primary_key: "name"
      path: "data_attributes"
      model: "company"
  contact_attributes:
    description: "https://developers.intercom.com/intercom-api-reference/reference#list-data-attributes"
    $ref: "*ref(definitions.stream_data_attributes)"
    $options:
      name: "contact_attributes"
      primary_key: "name"
      path: "data_attributes"
      model: "contact"
  segments:
    description: "https://developers.intercom.com/intercom-api-reference/reference#list-segments"
    $ref: "*ref(definitions.stream_full_refresh)"
    $options:
      name: "segments"
      primary_key: "id"
      path: "segments"
      data_field: "segments"
  companies:
    description: "https://developers.intercom.com/intercom-api-reference/reference/scroll-over-all-companies"
    $ref: "*ref(definitions.stream_full_refresh)"
    $options:
      name: "companies"
      primary_key: "id"
      path: "companies/scroll"
    # override
    retriever:
      $ref: "*ref(definitions.stream_full_refresh.retriever)"
      paginator:
        type: "DefaultPaginator"
        url_base: "*ref(definitions.requester.url_base)"
        pagination_strategy:
          type: "CursorPagination"
          cursor_value: "{{ response.get('scroll_param') }}"
          stop_condition: "{{ not response.get('data') }}"
          page_size: 50
        page_size_option:
          field_name: per_page
          inject_into: request_parameter
        page_token_option:
          field_name: scroll_param
          inject_into: request_parameter
      requester:
        $ref: "*ref(definitions.requester)"
        error_handler:
          type: CompositeErrorHandler
          error_handlers:
            - type: DefaultErrorHandler
              description: "
                400 - existing scroll_param, need to wait at least 60 sec to continue and retry
                500 - server-side error, should retry after 60 sec.
                "
              response_filters:
                - http_codes: [ 400, 500 ]
                  action: RETRY
              max_retries: 3
              backoff_strategies:
                - type: ConstantBackoffStrategy
                  backoff_time_in_seconds: 60
            - type: DefaultErrorHandler
              description: "404 - scroll_param is expired or not found while requesting, ignore"
              response_filters:
                - http_codes: [ 404 ]
                  action: IGNORE
  
  ## Incremental
  contacts:
    $ref: "*ref(definitions.stream_incremental_search)"
    $options:
      name: "contacts"
      path: "contacts/search"
      page_size: 150
      sort_order: "ascending"
      stream_cursor_field: "updated_at"
  conversations:
    $ref: "*ref(definitions.stream_incremental_search)"
    $options:
      name: "conversations"
      path: "conversations/search"
      page_size: 150
      sort_order: "ascending"
      data_field: "conversations"
      stream_cursor_field: "updated_at"
     
  conversation_parts:
    $ref: "*ref(definitions.stream_full_refresh)"
    $options:
      name: "conversation_parts"
      primary_key: "id"
      path: "/conversations/{{ stream_slice.id }}"
      stream_cursor_field: "updated_at"
    transformations:
      - type: AddFields
        fields:
          - path: ["conversation_id"]
            value: "{{ stream_slice.id }}"
    retriever:
      $ref: "*ref(definitions.stream_full_refresh.retriever)"
      requester:
        $ref: "*ref(definitions.requester)"
      record_selector:
        $ref: "*ref(definitions.selector_conversation_parts)"     
      paginator:
        type: "NoPagination"
      stream_slicer:
        type: "SubstreamSlicer"
        parent_stream_configs:
          - stream: "*ref(definitions.conversations)"
            parent_key: "id"
            stream_slice_field: "id"
    

streams:
  - "*ref(definitions.admins)"
  - "*ref(definitions.tags)"
  - "*ref(definitions.teams)"
  - "*ref(definitions.segments)"
  - "*ref(definitions.companies)"
  - "*ref(definitions.company_attributes)"
  - "*ref(definitions.contact_attributes)"
  - "*ref(definitions.contacts)"
  - "*ref(definitions.conversations)"
  - "*ref(definitions.conversation_parts)"

check:
  stream_names: 
    - "tags"
